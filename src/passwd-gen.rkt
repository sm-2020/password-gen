#lang racket/base

(require racket/random
         racket/math
         racket/format
         racket/port)


;; Generate a cryptographically secure random number of at least BITS bits
;; (BITS is rounded up to the next multiple of 8).  Returns the random number
;; as an integer
(define (random-num bits)
  (define num-bytes (exact-ceiling (/ bits 8)))
  (for/fold ([result 0])
            ([byte (in-bytes (crypto-random-bytes num-bytes))])
       (+ byte (* result 256))))

;; ~r function is limited to base 36, hence the need for custom encoding so that
;; upper, lower, symbols and numbers can be used in the password.
;;
;; Encode KEY, a random integer produced by `random-bignum`, using ALPHABET,
;; which is a list of symbols to use for the encoding (see alphabet
;; definitions below).  If GROUP is greater than 0, than SEPARATOR will be
;; inserted every GROUP symbols, this is intended to produce passwords that
;; are easier to read out and type by hand.
;;
;; NOTE: the choice of alphabet does not affect how strong a password is, the
;; strength of the password is determined by the random number generated by
;; `random-bignum`.  However, alphabets with more symbols will produce shorter
;; passwords for the same strength.
(define (encode-bignum bignum alphabet group separator)
  (define base (string-length alphabet))
  (let loop ([position 0]
             [result '()]
             [bignum bignum])
    (if (> bignum 0)
        (let-values (([q r] (quotient/remainder bignum base)))
          (let ((symbol (string-ref alphabet r)))
            ;; NOTE: if `group` is 0, there is no grouping
            (if (and (> group 0) (> position 0) (= (remainder position group) 0))
                (loop (add1 position) (cons symbol (cons separator result)) q)
                (loop (add1 position) (cons symbol result) q))))
        (list->string (reverse result)))))

;; Allows allcharecters in the password
(define full-alphabet
  (string-append
   "abcdefghijklmnopqrstuvwxyz"
   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
   "0123456789"
   "~!@#$%^&*_+-=|{}[]<>?,./"))

(define normal-alphabet
  (string-append "abcdefghijklmnopqrstuvwxyz"
                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                 "0123456789"))

(define lower-case-alphabet
  (string-append "abcdefghijklmnopqrstuvwxyz" "0123456789"))

(define simplified-alphabet "acefghkrstwxyz23456789")

;; Process command line arguments in order to  run password-gen
(module+ main
  (require racket/cmdline)
  ;;script arguments with defaults
  (define bits 128)
  (define alphabet full-alphabet)
  (define grouping 0)

  ;; Utility functions for command line argument processing
  (define (set-bits arg)
    (let ((value (string->number arg)))
      (if (and (number? value) (integer? value) (> value 64))
          (set! bits value)
          (error "invalid number of bits for the password, must be at least 64"))))

  (define (set-alphabet arg)
    (set! alphabet
          (cond ((string-ci=? arg "full") full-alphabet)
                ((string-ci=? arg "normal") normal-alphabet)
                ((string-ci=? arg "lower-case") lower-case-alphabet)
                ((string-ci=? arg "simplified") simplified-alphabet)
                (#t (error "unknown alphabet type")))))

   (define (set-grouping arg)
    (let ((value (string->number arg)))
      (if (and (number? value) (integer? value) (> value 0))
          (set! grouping value)
          (error "invalid grouping, must be a positive integer"))))
  ;; Read command line arguments and set parameters
  (command-line
   #:program "pwgen"
   #:usage-help "" "pwgen is a program to generate random passwords" ""
   #:once-each
   (("-b" "--bits")
    arg
    "number of random bits in the password"
    (set-bits arg))
   
   (("-a" "--alphabet")
    arg
    ("alphabet to use for encoding"
     "must be one of: 'full', 'normal', 'lower-case' or 'simplified'")
    (set-alphabet arg))
  
   (("-g" "--group")
    arg
    "group characters of <arg> items, use 0 for no grouping"
    (set-grouping arg)))

 ;; Generate the password with the supplied arguments
 (define n (random-num bits))
 (printf "~a~%" (encode-bignum n alphabet grouping #\-)))

;;---------------------------------------------------------------------------------
;(define number (random-num 128))
;(for ([base '(10 16 20 32 36)])
;    (define e (~r number #:base base))
;    (printf "base: ~a, length: ~a, number: ~a~%"
;             base (string-length e) e))
;(printf "~a\n" (number->string number))
;(printf (encode-num number "abcdef")))
